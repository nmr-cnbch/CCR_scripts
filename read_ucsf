#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 15 12:55 2022

@author: Paulina Bartosinska-Marzec
"""
""" Program do czytania widm w formacie ucsf i wypisywanie wartości dla danych punktów w widmie """



from copy import deepcopy
from random import randint
import struct
import sys
from itertools import product
import os
import numpy


if len(sys.argv)==1:
    sys.exit("""
    read_ucsf script after reading ucsf file and peak list (in Sparky format), check peak intensity of peak and if it is not in the highest position - move it. 
    After this script prints peak lists in ppm value and points value.
    
    For run script type in command line:
        python3 read_ucsf [ucsf path] [peak list path]
      
    additionaly you can add:
        --np [num]\t- to change number of points for calculate noise level: N^(spectra dimentionality + 1); normally is N = 10
        --plevel [num]\t- if you know level when starting appear, add this with scientific numer notation e.g. 1e+7
        --norm or --noRemove\t- add this if you do not want remove invisible peaks
        --onlypoints\t- add this if you want only change ppm value to points value
        --o or --output_name\t- add this if you want only change ppm value to points value\n""")



file_name = sys.argv[1]
peak_list = sys.argv[2]


if "--np" in sys.argv:
    i = sys.argv.index("--np")
    number_of_points_for_noise=int(sys.argv[i+1])
else:
    number_of_points_for_noise=10

if "--plevel" in sys.argv:
    i = sys.argv.index("--plevel")
    peak_level=float(sys.argv[i+1]) 

print (number_of_points_for_noise)


if "--norm" in sys.argv:
    noRemoveFlag = True
    print ("noRemoveFlag is on")
elif "--noRemove" in sys.argv:
    noRemoveFlag = True
    print ("noRemoveFlag is on")
else:
    noRemoveFlag = False


if "--onlypoints" in sys.argv:
    OnlyPoints = True
    print ("OnlyPoints option is on")
else:
    OnlyPoints = False

# Output name
if "--o" in sys.argv:
    i = sys.argv.index("--o")
    peak_list_name = sys.argv[i+1][:-5]
    list_name = peak_list_name.split(".")
    peak_list_dir_new = list_name[0]+"_list"
    # peak_list_dir_new = peak_list_name[:-(len(peak_list_name)+5)]
    if not os.path.exists(peak_list_dir_new):
        os.mkdir(peak_list_dir_new)
    print ("Output file path: {}/{}.list".format(peak_list_dir_new,peak_list_name))
elif "--output_name" in sys.argv:
    i = sys.argv.index("--output_name")
    peak_list_name = sys.argv[i+1][:-5]
    list_name = peak_list_name.split(".")
    peak_list_dir_new = list_name[0]+"_list"
    if not os.path.exists(peak_list_dir_new):
        os.mkdir(peak_list_dir_new)
    print ("Output file path: {}/{}.list".format(peak_list_dir_new,peak_list_name))
else: 
    item = peak_list.split("/")
    peak_list_name = item[len(item)-1][:-5]
    peak_list_dir_new = peak_list[:-(len(peak_list_name)+5)]+peak_list_name
    if not os.path.exists(peak_list_dir_new):
        os.mkdir(peak_list_dir_new)
    print ("Output file path: {}/{}".format(peak_list_dir_new,peak_list_name))

    






class CPeak:
    def __init__(self):
        self.peak_ppm_pos = []            # chemical shifts for all nuclei of peak, length depends on dimentionality
        self.peak_points_pos = []      # peak position in points
        self.is_visible = True         # if peak height is 50 time biger than noise level = True
        self.peak_intens = 0            # peak height  
        self.descript = ""              
        self.is_center = False          # if peak is in the highest point = True
        self.was_moved = False          # if peak was moved = True
        self.new_points_pos = []         # if peak was moved there will be new position in points
        self.new_ppm_pos = []           # if peak was moved there will be new position in ppm









"""Reading functions"""

def read_peaklist(peak_list, s_dim):
    with open(peak_list, 'r') as pl:
        p_lines = pl.readlines()
        p_list = []
        for indexl, line in enumerate(p_lines):
            if indexl > 1 :
                p_pos = CPeak()
                item = line.split()
                p_pos.descript = item[0]
                # print ("p_pos.peak_ppm_pos", p_pos.peak_ppm_pos)
                p_pos.peak_ppm_pos.append(deepcopy(float(item[s_dim])))
                for i in range(1,s_dim):
                    p_pos.peak_ppm_pos.append(deepcopy(float(item[i])))
                p_list.append(deepcopy(p_pos))
                # print (p_pos.peak_ppm_pos)       
    return p_list


def read_ucsf_info(file_name):
    nucl_name = []
    points_num = []
    tile_size = []
    spectr_fq =[]
    sw = []
    sw_ppm = []
    centr_data = []

    with open(file_name, "rb") as ucsf_file:
        """Read spectra dimentionality"""
        ucsf_file.seek(10)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_dim = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value 
        print ("spectra_dim", spectra_dim)

        """Read spectra format"""
        ucsf_file.seek(13)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_format = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value  

        """Read nucleus name"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(180+128*i)                                       # nucleus name (1H, 13C, 15N, 31P); first is after 180 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(6)                                   # 6 byte per information 
            text_data = ucsf_data.decode('utf-8')                           # convert bytes to string    
            # print ("nucleus name", ucsf_data, "\t", text_data)
            # print (text_data)
            nucl_name.append(deepcopy(text_data))
            # print (nucl_name[0])
        nucl_name.insert(0,nucl_name.pop())
        # print ("tutaj", nucl_name[0], nucl_name[1],nucl_name[2],nucl_name[3])
        # for ii in range(len(nucl_name)):
        #     print("bbb", nucl_name[ii])
        # print (nucl_name)

        """Read number of points per asix"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(188+128*i)                                       # integer number of data points along axis; first is after 188 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("points_num", ucsf_data, "\t", bytes2int)
            points_num.append(deepcopy(bytes2int)) 
        points_num.insert(0,points_num.pop())

        """Read integer tile size along this axis"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(196+128*i)                                       # integer tile size along this axis; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("tile size", ucsf_data, "\t", bytes2int)
            tile_size.append(deepcopy(bytes2int))
        tile_size.insert(0,tile_size.pop())
        # print (tile_size)

        """Read float spectrometer frequency for this nucleus (MHz) """
        for i in range(0,spectra_dim):
            ucsf_file.seek(200+128*i)                                       # float spectrometer frequency for this nucleus (MHz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            spectr_fq.append(deepcopy(bytes2float))
        spectr_fq.insert(0,spectr_fq.pop())
        # print ("spectr_fq", spectr_fq)

        """Read float spectral width (Hz)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(204+128*i)                                       # float spectral width (Hz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            sw.append(deepcopy(bytes2float))
        sw.insert(0,sw.pop())

        """Read float center of data (ppm)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(208+128*i)                                       # float center of data (ppm) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            centr_data.append(deepcopy(bytes2float))
        centr_data.insert(0,centr_data.pop())
        # print ("centr_data",centr_data)

    """Change spectral width from Hz to ppm"""
    for p in range(len(sw)):
        sw_sparky = sw[p]-(sw[p]/points_num[p])
        sw_ppm.append(deepcopy(sw_sparky/spectr_fq[p]))
    
    # print ("spectr_fq", spectr_fq)
    # print ("centr_data",centr_data)
    # print ("sw =", sw, "\nsw_ppm =", sw_ppm)
    n_tiles=[]                                 # number of tiles along axis [direct, 1, 2, 3]                                # point number with peak in tile  

    for i in range (0,spectra_dim):
        if points_num[i]%tile_size[i]==0:
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])))
        else: 
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])+1))

    return spectra_dim, nucl_name, points_num, tile_size, spectr_fq, sw, sw_ppm, centr_data, n_tiles







"""Calculating functions"""

def ppm2points(ppm, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    point_value = round((downfield-ppm)/(sw_div_fnz))
    return point_value

def ppm2points_float(ppm, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    point_value = round((downfield-ppm)/(sw_div_fnz),2)
    return point_value

def points2ppm(point_value, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    ppm_value = downfield-point_value*sw_div_fnz
    return ppm_value


def calc_peak_points(points_num, peaks, sw_ppm, center_data,s_dim,num_format="Integer"):
    for peak_num in range(len(peaks)):
        for p in range(len(peaks[peak_num].peak_ppm_pos)):
            if num_format == "Integer":
                one_dim = ppm2points(peaks[peak_num].peak_ppm_pos[p],points_num[p],center_data[p],sw_ppm[p])
            elif num_format == "Float":
                one_dim = ppm2points_float(peaks[peak_num].peak_ppm_pos[p],points_num[p],center_data[p],sw_ppm[p])
            peaks[peak_num].peak_points_pos.append(deepcopy(one_dim))
    Print_Peak_List_points(peaks, s_dim, "orgin")
    return peaks



def find_noise_point(peaks, s_dim, points_num, number_of_points_for_noise):

    dumpster=[]                              # list of wrong points: e.g. it's peak or really close to peak
    for i in range(len(peaks)):
        dumpster.append(deepcopy(peaks[i].peak_points_pos))
    suspect_peaks=[]                                        # list of peaks which probably are too close to our random point
    list_of_points=[]                 # list of good points with noise

    first_try = [None]*s_dim


    print ("number_of_points_for_noise", number_of_points_for_noise**(1+s_dim))
    ii=1
    while len(list_of_points)< number_of_points_for_noise**(1+s_dim):
        
        for f in range(len(first_try)):
            first_try[f]=randint(0,points_num[f]-1) # points_num[f]-1 because it takes too big number
        
        # print (first_try)
        if first_try not in dumpster:
            # print ("first_try - ok")
            for indexi, one_peak in enumerate(peaks):
                if first_try[0] in range (one_peak.peak_points_pos[0]-3, one_peak.peak_points_pos[0]+3):
                    suspect_peaks.append(deepcopy(one_peak.peak_points_pos))
                    for i in range(1,len(one_peak.peak_points_pos)):
                        if first_try[i] not in range (one_peak.peak_points_pos[i]-3, one_peak.peak_points_pos[i]+3):
                            suspect_peaks.pop()
                            break
            # print ("suspect_peaks", ii, suspect_peaks)

            if len(suspect_peaks) == 0:
                list_of_points.append(deepcopy(first_try))
            else:
                dumpster.append(deepcopy(suspect_peaks))
            suspect_peaks.clear()
            ii+=1
    # print (list_of_points)
    print ("ile wyrzuciles?", len(peaks), "--->", len(dumpster))

    return list_of_points


def calc_list_of_points(peak_point, tile_size):
    L=[]                                        # tile number with our peak -1
    R=[]                                        # point number with peak in tile  
    for one_peak_point in peak_point:
        l=[]
        r=[]
        for p in range(len(one_peak_point)):
            l.append(deepcopy(one_peak_point[p]//tile_size[p]))
            r.append(deepcopy(one_peak_point[p]%tile_size[p]))
        R.append(deepcopy(r))
        L.append(deepcopy(l))

    return L, R


def read_intens(peak_pos_list, file_name, s_dim, tile_size, n_tiles):

    L, R = calc_list_of_points(peak_pos_list, tile_size)       # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
    intens_list=[]

    for k in range(len(peak_pos_list)):
        
        '''  Calculation starting point in ucsf file for peak "k"  '''

        ppos = [None]*s_dim*2
        for D in range(1,s_dim):
            pp = 1
            rr = 1
            for d in range(D+1,s_dim):
                pp = pp * n_tiles[d]                        # Calculating terms with quantities and sizes of tiles
                rr = rr * tile_size[d]                      # Calculating terms with position points in a given tiles
            pp = pp * L[k][D] * numpy.prod(tile_size) * n_tiles[0]
            rr = rr * R[k][D] * tile_size[0]
            ppos[D-1]=pp
            ppos[D-1+s_dim]=rr
        ppos[s_dim-1]=L[k][0] * numpy.prod(tile_size)
        ppos[s_dim*2-1]=R[k][0]
        ppos_sum=180+128*s_dim+sum(ppos)*4

        '''  Reading value from ucsf file for peak "k"  '''
        with open(file_name, "rb") as ucsf_file:
            ucsf_file.seek(ppos_sum)                                       
            ucsf_data = ucsf_file.read(4)
            [bytes2float] = struct.unpack('>f', ucsf_data)
            intens_list.append(deepcopy(bytes2float))
        

    return intens_list


def find_points_around(try_position, orgin_pos, vector_set, s_dim):
    list_of_points=[]

    for i in range (len(vector_set)):
        Flag = False
        one_point = []
        for j in range (s_dim):
            new_point = try_position[j] + vector_set[i][j]
            if abs(new_point-orgin_pos[j])<=2:
                one_point.append(deepcopy(new_point))
            else:
                Flag = True
        if Flag==False:
            list_of_points.append(deepcopy(one_point))


    return list_of_points


def intens_aroun_peak(try_position, orgin_pos, file_name, s_dim, tile_size, n_tiles):
    vector_set2 = [-1,0,1]
    list_of_around_points = []
    for k in range(s_dim):
        for i in vector_set2:
            TestList = try_position[:]
            TestList[k] += i
            if abs(TestList[k]-orgin_pos[k])<=2:
                list_of_around_points.append(deepcopy(TestList))
    try_index = list_of_around_points.index(try_position)
    points_intens = read_intens(list_of_around_points, file_name, s_dim, tile_size, n_tiles)

    return list_of_around_points, points_intens, try_index



def Print_Peak_List_ppm(peaks, s_dim, points_num, sw_ppm, center_data):
    new_peak_list = "{0}/{1}_new_ppm.list".format(peak_list_dir_new,peak_list_name)
    print ("new_peak_list", new_peak_list)
    max_lenth_discrip = 0
    for p in peaks:
        if len(p.descript)>max_lenth_discrip:
            max_lenth_discrip=len(p.descript)
    with open(new_peak_list, 'w') as listfile:
        print ("\tAssignment", end="", file=listfile) 
        for i in range(s_dim):
            print ("\tw{}".format(i+1), end="", file=listfile)
        print ("\tData Height\t\t\t\tCentering peak list prepare from{}\n".format(peak_list_name), file=listfile)
        for indexpeak, one_peak in enumerate(peaks):
            if one_peak.is_visible == True:
                print ("{:{sentence_len}}".format(one_peak.descript, sentence_len=max_lenth_discrip), end="\t", file=listfile)
                if one_peak.was_moved == True and one_peak.is_center != False:
                    for i in range(1,s_dim):
                        ppm_position = points2ppm(one_peak.new_points_pos[i], points_num[i],center_data[i],sw_ppm[i])
                        print ("{:.3f}".format(ppm_position), end="\t", file=listfile)
                    ppm_position = points2ppm(one_peak.new_points_pos[0], points_num[0],center_data[0],sw_ppm[0])
                    print ("{:.3f}".format(ppm_position), end="\t", file=listfile)
                        
                else: 
                    for i in range(1,s_dim):
                        print ("{:.3f}".format(one_peak.peak_ppm_pos[i]), end="\t", file=listfile)
                    print ("{:.3f}".format(one_peak.peak_ppm_pos[0]), end="\t", file=listfile)
                print (one_peak.peak_intens, end=" ", file=listfile) 
                
                if one_peak.is_center == False:
                    print ("to check", file=listfile)
                else: print (file=listfile)
    return

def Print_Peak_List_points(peaks, s_dim, type_list):
    # item = peak_list.split("/")
    # peak_list_name = item[len(item)-1][:-5]
    # peak_list_dir_new = peak_list[:-(len(peak_list_name)+5)]+peak_list_name
    # if not os.path.exists(peak_list_dir_new):
    #     os.mkdir(peak_list_dir_new)
    new_peak_list = "{0}/{1}_{2}_points.list".format(peak_list_dir_new,peak_list_name,type_list)
    print ("{} peak list".format(type_list), new_peak_list)
    with open(new_peak_list, 'w') as listfile:
        print ("\tAssignment", end="", file=listfile) 
        for i in range(s_dim):
            print ("\tw{}".format(i+1), end="", file=listfile)
        if type_list == "orgin":
            print ("\tData Height\t\t\t\t Orgin peaklist in points\n", file=listfile)
        else:
            print ("\tData Height\t\t\t\tCentering peak list prepare from{}\n".format(peak_list_name), file=listfile)
        for one_peak in peaks:
            if one_peak.is_visible == True:
                print ("{}".format(one_peak.descript), end="\t", file=listfile)
                if one_peak.was_moved == True and one_peak.is_center != False:
                    for i in range(1,s_dim):
                        print ("{}".format(one_peak.new_points_pos[i]), end="\t", file=listfile)
                    print ("{}".format(one_peak.new_points_pos[0]), end="\t", file=listfile)
                else: 
                    for i in range(1,s_dim):
                        print ("{}".format(one_peak.peak_points_pos[i]), end="\t", file=listfile)
                    print ("{}".format(one_peak.peak_points_pos[0]), end="\t", file=listfile)
                if one_peak.peak_intens:
                    print (one_peak.peak_intens, end=" ", file=listfile) 
                if type_list=="new" and one_peak.is_center == False:
                    print ("to check", file=listfile)
                else: print (file=listfile)
    return





















"""                      MAIN PROGRAM                      """

# print ("\n\nSTART")
"""File Reading"""

print ("File reading - start")
Spectra_dim, Nucl_name, Points_number, Tile_size, Spectrometer_fq, SW_size, SW_size_ppm, Centr_data, N_Tiles = read_ucsf_info (file_name)
Peaks = read_peaklist(peak_list, Spectra_dim)                       # reading position of peak from peak list in Sparky format
print ("---> finished")

if OnlyPoints:
    Peaks = calc_peak_points(Points_number, Peaks, SW_size_ppm, Centr_data, Spectra_dim, "Float")
    # OldPeakList_points = Print_Peak_List_points(Peaks, Spectra_dim, "orgin")
else:
    Peaks = calc_peak_points(Points_number, Peaks, SW_size_ppm, Centr_data, Spectra_dim)
    OldPeakList_points = Print_Peak_List_points(Peaks, Spectra_dim, "orgin")
    # OldPeakList_points = Peaks[:]         ### I tried print orgin peak list in points with peak high  
    # # for i in Peaks:
    # #     OldPeakList_points.append(deepcopy(i.peak_points_pos))
    # # # print (OldPeakList_points)
    # read_intens(OldPeakList_points, file_name, Spectra_dim, Tile_size, N_Tiles)
    # Print_Peak_List_points(OldPeakList_points, Spectra_dim, "orgin")

    """Noise calculation"""
    try:
        print ("peak level starts from = {:.2e}".format(peak_level))
    except NameError:
        print ("\nNoise calculation - start")
        List_of_noise_points = find_noise_point(Peaks, Spectra_dim, Points_number, number_of_points_for_noise)
        Points_intens = read_intens(List_of_noise_points, file_name, Spectra_dim, Tile_size, N_Tiles)
        abs_Points_intens = list(map(abs,Points_intens))
        sum_Points_intens = sum(abs_Points_intens)
        average_noise_level = round(sum_Points_intens/len(Points_intens), 1)
        print ("average noise level = {:.2e}".format(average_noise_level))
        print ("50*average noise level = {:.2e}".format(50*average_noise_level))
        peak_level = 50*average_noise_level
        print ("Noise calculation - finished")


    """Center peaks and read intens"""
    print ("\nCenter peaks and read intens - start")
    Peak_not_moved = 0
    Peak_moved = 0
    # Vector_set = [list(row) for row in (product([-1, 0, 1],repeat=4))]
    Vector_set2 = [-1,0,1]

    with open('{}/peakcenter.txt'.format(peak_list_dir_new), 'w') as txtfile:
        print ("Peak_not_moved =     \nPeak_moved =     ",file=txtfile)
    for indexpeak, one_peak in enumerate(Peaks):
        Try_position = one_peak.peak_points_pos
        Orgin_pos = one_peak.peak_points_pos
        try_pos=[]
        try_intens=[]
        while one_peak.is_center == False:
            List_of_around_points, Points_intens, try_index = intens_aroun_peak(Try_position, Orgin_pos, file_name, Spectra_dim, Tile_size, N_Tiles)
            try_pos.append(deepcopy(Try_position))
            try_intens.append(deepcopy(Points_intens[try_index]))
            if Points_intens[try_index] > 0 :
                maximum = max
            else: 
                maximum = min    
            if abs(Points_intens[try_index]) > peak_level or noRemoveFlag==True:
                if Points_intens.index(maximum(Points_intens)) != try_index:            # if current position of peak is not the highest: index of the highest point is not equal 0 (0 is index of current peak position)
                    Try_position = List_of_around_points[Points_intens.index(maximum(Points_intens))]
                    # print ("Peak:", indexpeak, "must move")
                    one_peak.was_moved = True
                else:
                    one_peak.is_center = "maybe"
                    one_peak.peak_intens = Points_intens[try_index]
                    # print ("Peak:", indexpeak, "is in the highest place")
                    
                    if one_peak.was_moved == True:
                        one_peak.new_points_pos = Try_position
                        Peak_moved +=1
                    else: Peak_not_moved +=1
            else: 
                one_peak.is_visible = False
                # print ("Peak:", indexpeak, "is not visible")
                break

        #check if peak is in the highest position
        List_of_around_points, Points_intens, try_index = intens_aroun_peak(Try_position, Orgin_pos, file_name, Spectra_dim, Tile_size, N_Tiles)
        if Points_intens[try_index] > 0 :
                maximum = max
        else: 
                maximum = min    
        if Points_intens.index(maximum(Points_intens)) == try_index:
            one_peak.is_center = True
        else: 
            one_peak.is_center = False

        with open('{}/peakcenter.txt'.format(peak_list_dir_new), 'a') as txtfile:
            if one_peak.is_visible == False:
                print ("\n{}\t({})\t- is not visible".format(indexpeak, one_peak.descript), file=txtfile)
            else:
                print ("\n{}\t({})".format(indexpeak, one_peak.descript), file=txtfile)

            for i in range(len(try_pos)):
                print ("\t", try_pos[i], try_intens[i], sep="\t", file=txtfile)
            if one_peak.is_center == False:
                print ("\t\t\t\t\t\t\tis not in the highest position", file=txtfile)

    with open('{}/peakcenter.txt'.format(peak_list_dir_new), 'r+') as txtfile:
        # file_data = txtfile.read()
        txtfile.seek(0,0)
        # txtfile.write()
        print ("Peak_not_moved = {}\nPeak_moved = {}".format(Peak_not_moved,Peak_moved),file=txtfile)

    print ("Center peaks and read intens - finished")


    """Print peak list"""
    print ("\nPrint peak list - start")

    NewPeakList_ppm = Print_Peak_List_ppm(Peaks, Spectra_dim, Points_number, SW_size_ppm, Centr_data)
    NewPeakList_points = Print_Peak_List_points(Peaks, Spectra_dim, "new")
    print ("\nPrint peak list - finish")

#### Check intensity of points around the peak
# TestList = [30, 31, 157, 107]
# moves = [-2,-1,0,1,2]
# with open('{}/intensmap.txt'.format(peak_list_dir_new), 'w') as txtmap:
#     print ("Maps of intensity of points around peak:{}\n\n".format(TestList),file=txtmap)

#     duzalista = []
#     for k in range(4):
        
#         malalista = []
#         for i in moves:
#             TestList = [30, 31, 157, 107]
#             TestList[k] += i
#             malalista.append(deepcopy(TestList))
#         jedna_linia = read_intens(malalista, file_name, Spectra_dim, Tile_size, N_Tiles)
#         duzalista.append(deepcopy(malalista))
#         print ("index = {}".format(k), end="\t", file=txtmap)
#         for p in jedna_linia:
#             print ("{:^20}".format(p), end="\t", file=txtmap)
#         print ("\n\t\t", end="\t", file=txtmap)
#         for b in malalista:
#             print ("{:^20}".format(str(b)), end="\t", file=txtmap)
#         print ("\n",file=txtmap)


 
print ("\n\nKONIEC\n\n")
# Try_point_list=[692]
# try_point(Try_point_list)