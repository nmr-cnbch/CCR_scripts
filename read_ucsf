#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 15 12:55 2022

@author: Paulina Bartosinska-Marzec
"""
""" Program do czytania widm w formacie ucsf i wypisywanie wartości dla danych punktów w widmie """

""" terminal: python3 read_ucsf [spectra path] [peak list] [] [] """

import binascii
from copy import deepcopy
from curses import endwin
from importlib.resources import read_binary
import math
from random import randint
import readline
import struct
import sys

import numpy
# import struct
# import _struct

file_name = sys.argv[1]
peak_list = sys.argv[2]

if len(sys.argv)>3:
    number_of_points_for_noise=int(sys.argv[3])
else:
    number_of_points_for_noise=10



class CPeak:
    def __init__(self):
        self.peak_pos = []            # chemical shifts for all nuclei of peak, length depends on dimentionality
        self.peak_points_pos = []      # peak position in points
        self.is_visible = True         # if peak height is 50 time biger than noise level = True
        self.is_center = False          # if peak is in the highest st point = True
        self.peak_intens = 0            # peak height  
        self.descript = ""              









"""Reading functions"""

def read_peaklist(peak_list, s_dim):
    with open(peak_list, 'r') as pl:
        p_lines = pl.readlines()
        p_list = []
        p_pos = CPeak()
        for indexl, line in enumerate(p_lines):
            if indexl > 1 :
                p_pos.peak_pos = line.split()
                # print ("p_pos.peak_pos", p_pos.peak_pos)
                if len(p_pos.peak_pos)>s_dim: 
                    s = s_dim-1
                    e = len(p_pos.peak_pos)-1
                    p_pos.descript = p_pos.peak_pos[0]
                    del p_pos.peak_pos[0]
                    del p_pos.peak_pos[s_dim:len(p_pos.peak_pos)]
                p_pos.peak_pos.insert(0,p_pos.peak_pos.pop())
                # print ("p_pos.peak_pos", p_pos.peak_pos)
                for i in range(len(p_pos.peak_pos)):
                    p_pos.peak_pos[i]=float(p_pos.peak_pos[i])
                p_list.append(deepcopy(p_pos))
                # print (p_pos.peak_pos)       
    return p_list


def read_ucsf_info(file_name):
    nucl_name = []
    points_num = []
    tile_size = []
    spectr_fq =[]
    sw = []
    sw_ppm = []
    centr_data = []

    with open(file_name, "rb") as ucsf_file:
        """Read spectra dimentionality"""
        ucsf_file.seek(10)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_dim = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value 

        """Read spectra format"""
        ucsf_file.seek(13)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_format = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value  

        """Read nucleus name"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(180+128*i)                                       # nucleus name (1H, 13C, 15N, 31P); first is after 180 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(6)                                   # 6 byte per information 
            text_data = ucsf_data.decode('utf-8')                           # convert bytes to string    
            # print ("nucleus name", ucsf_data, "\t", text_data)
            # print (text_data)
            nucl_name.append(deepcopy(text_data))
            # print (nucl_name[0])
        nucl_name.insert(0,nucl_name.pop())
        # print ("tutaj", nucl_name[0], nucl_name[1],nucl_name[2],nucl_name[3])
        # for ii in range(len(nucl_name)):
        #     print("bbb", nucl_name[ii])
        # print (nucl_name)

        """Read number of points per asix"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(188+128*i)                                       # integer number of data points along axis; first is after 188 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("points_num", ucsf_data, "\t", bytes2int)
            points_num.append(deepcopy(bytes2int)) 
        points_num.insert(0,points_num.pop())

        """Read integer tile size along this axis"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(196+128*i)                                       # integer tile size along this axis; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("tile size", ucsf_data, "\t", bytes2int)
            tile_size.append(deepcopy(bytes2int))
        tile_size.insert(0,tile_size.pop())
        # print (tile_size)

        """Read float spectrometer frequency for this nucleus (MHz) """
        for i in range(0,spectra_dim):
            ucsf_file.seek(200+128*i)                                       # float spectrometer frequency for this nucleus (MHz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            spectr_fq.append(deepcopy(bytes2float))
        spectr_fq.insert(0,spectr_fq.pop())
        # print (spectr_fq)

        """Read float spectral width (Hz)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(204+128*i)                                       # float spectral width (Hz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            sw.append(deepcopy(bytes2float))
        sw.insert(0,sw.pop())

        """Read float center of data (ppm)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(208+128*i)                                       # float center of data (ppm) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            centr_data.append(deepcopy(bytes2float))
        centr_data.insert(0,centr_data.pop())
        # print (centr_data)

    """Change spectral width from Hz to ppm"""
    for p in range(len(sw)):
        sw_sparky = sw[p]-(sw[p]/points_num[p])
        sw_ppm.append(deepcopy(sw_sparky/spectr_fq[p]))
    # print (sw, "\n", sw_ppm)
    return spectra_dim, nucl_name, points_num, tile_size, spectr_fq, sw, sw_ppm, centr_data







"""Calculating functions"""

def ppm2points(ppm, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    point_value = round((downfield-ppm)/(sw_div_fnz))
    # print ("point_value", ppm, "--->", point_value_float, "--->", point_value)
    return point_value


def calc_peak_points(points_num, peaks, sw_ppm, center_data):
    # peak_point=[]
    for peak_num in range(len(peaks)):
        # one_peak=[]
        for p in range(len(peaks[peak_num].peak_pos)):
            one_dim = ppm2points(peaks[peak_num].peak_pos[p],points_num[p],center_data[p],sw_ppm[p])
            # one_peak.append(deepcopy(one_dim))
            peaks[peak_num].peak_points_pos.append(deepcopy(one_dim))
        # peak_point.append(deepcopy(one_peak))
        # print (peaks[peak_num].peak_pos, peaks[peak_num].peak_points_pos)

    # print ("peak_point", peak_point)
    return peaks


def find_noise_point(peaks, s_dim, points_num, number_of_points_for_noise):

    dumpster=[]                              # list of wrong points: e.g. it's peak or really close to peak
    for i in range(len(peaks)):
        dumpster.append(deepcopy(peaks[i].peak_points_pos))
    suspect_peaks=[]                                        # list of peaks which probably are too close to our random point
    list_of_points=[]                 # list of good points with noise

    first_try = [None]*s_dim


    print ("number_of_points_for_noise", number_of_points_for_noise**(1+s_dim))
    ii=1
    while len(list_of_points)< number_of_points_for_noise**(1+s_dim):
        
        for f in range(len(first_try)):
            first_try[f]=randint(0,points_num[f]-1) # points_num[f]-1 because it takes too big number
        
        # print (first_try)
        if first_try not in dumpster:
            # print ("first_try - ok")
            for indexi, one_peak in enumerate(peaks):
                if first_try[0] in range (one_peak.peak_points_pos[0]-3, one_peak.peak_points_pos[0]+3):
                    suspect_peaks.append(deepcopy(one_peak.peak_points_pos))
                    for i in range(1,len(one_peak.peak_points_pos)):
                        if first_try[i] not in range (one_peak.peak_points_pos[i]-3, one_peak.peak_points_pos[i]+3):
                            suspect_peaks.pop()
                            break
            # print ("suspect_peaks", ii, suspect_peaks)

            if len(suspect_peaks) == 0:
                list_of_points.append(deepcopy(first_try))
            else:
                dumpster.append(deepcopy(suspect_peaks))
            suspect_peaks.clear()
            ii+=1
    # print (list_of_points)
    print ("ile wyrzuciles?", len(peaks), "--->", len(dumpster))

    return list_of_points


def calc_list_of_points(peak_point, s_dim, tile_size, points_num):
    n_tiles=[]                                 # number of tiles along axis [direct, 1, 2, 3]
    L=[]                                        # tile number with our peak -1
    R=[]                                        # point number with peak in tile  

    for i in range (0,s_dim):
        if points_num[i]%tile_size[i]==0:
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])))
        else: 
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])+1))
    
    for indexp, one_peak_point in enumerate(peak_point):
        # print ("\nnumer piku", indexp+1)
        l=[]
        r=[]
        for p in range(len(one_peak_point)):
            l.append(deepcopy(one_peak_point[p]//tile_size[p]))
            r.append(deepcopy(one_peak_point[p]%tile_size[p]))
            # print ("ppm2points", one_peak_point[p], "--",tile_size[p],"--> l =", l[p], "r =", r[p])
            # print ("ppm2points", one_peak_point[p], "---->", peak_point, "--",tile_size[p],"--> points_num =", points_num[p], "center_data =", center_data[p],"sw_ppm =", sw_ppm[p])
            # # print ("ppm2points", one_peak_point[p], "---->", peak_point)
        R.append(deepcopy(r))
        L.append(deepcopy(l))
    # print ("\n\nlisty L", L, "\nn_tiles", n_tiles, "\nR", R, "\n\n")

    return L, R, n_tiles


def read_intens(file_name, s_dim, tile_size, L, R, n_tiles, peak_pos_list):

    intens_list=[]

    for k in range(len(peak_pos_list)):
        
        '''  Calculation starting point in ucsf file for peak "k"  '''

        ppos = [None]*s_dim*2
        # print ("\n\nNUMER_PIKU = ", k+1, "\n")

        
        for D in range(1,s_dim):
            pp = 1
            rr = 1
            for d in range(D+1,s_dim):
                pp = pp * n_tiles[d]                        # Calculating terms with quantities and sizes of tiles
                rr = rr * tile_size[d]                      # Calculating terms with position points in a given tiles
                # print ("pp_1", pp, "= pp * n_tiles(", n_tiles[d], ")", "\t\td = ", d)
                # print ("rr_1", rr, "= rr * tile_size(", tile_size[d], ")", "\t\td = ", d)
            pp = pp * L[k][D] * numpy.prod(tile_size) * n_tiles[0]
            rr = rr * R[k][D] * tile_size[0]
            # print ("\npp_2 =", pp, "rr_2 =", rr, "L =", L[k][D], "D =", D, D+s_dim)
            ppos[D-1]=pp
            ppos[D-1+s_dim]=rr
        ppos[s_dim-1]=L[k][0] * numpy.prod(tile_size)
        ppos[s_dim*2-1]=R[k][0]
        ppos_sum=180+128*s_dim+sum(ppos)*4
        # print ("\nnumer_piku = ", k+1, "\tppos_sum = ", ppos_sum, "przed:", sum(ppos))
        # print ("ppos", ppos)

        '''  Reading value from ucsf file for peak "k"  '''
        with open(file_name, "rb") as ucsf_file:
            ucsf_file.seek(ppos_sum)                                       
            ucsf_data = ucsf_file.read(4)
            # print (ucsf_data)
            [bytes2float] = struct.unpack('>f', ucsf_data)
            # print ("bytes2float", bytes2float)
            intens_list.append(deepcopy(bytes2float))
        
    # print ("\nintens_list", intens_list)

    return intens_list


def find_points_around(try_position, s_dim, points_num):
    list_of_points=[]
    range_list = [0, -1, 1]
    
    if s_dim == 4:
        for i in range_list:
            for j in range_list:
                for k in range_list:
                    for l in range_list:
                        if try_position[0]+i>=0 and try_position[1]+j>=0 and try_position[2]+k>=0 and try_position[3]+l>=0:
                            one_point=[try_position[0]+i,try_position[1]+j,try_position[2]+k,try_position[3]+l]
                            list_of_points.append(deepcopy(one_point))
        # print (len(list_of_points), "z", 3**4)
    
    elif s_dim == 3:
        for i in range_list:
            for j in range_list:
                for k in range_list:
                    if try_position[0]+i>=0 and try_position[1]+j>=0 and try_position[2]+k>=0 :
                        one_point = [try_position[0]+i,try_position[1]+j,try_position[2]+k]
                        list_of_points.append(deepcopy(one_point))
        # print (len(list_of_points), "z", 3**3)
    
    elif s_dim == 2:
        for i in range_list:
            for j in range_list:
                if try_position[0]+i>=0 and try_position[1]+j>=0 :
                    one_point = [try_position[0]+i,try_position[1]+j]
                    list_of_points.append(deepcopy(one_point))
        # print (len(list_of_points), "z", 3**2)
    else:
        print ("This dimentionality of spectra is not supported")

    return list_of_points




"""                      MAIN PROGRAM                      """

# print ("\n\nSTART")
"""File Reading"""
print ("File reading - start", end=" ")
Spectra_dim, Nucl_name, Points_number, Tile_size, Spectrometer_fq, SW_size, SW_size_ppm, Centr_data = read_ucsf_info (file_name)
Peaks = read_peaklist(peak_list, Spectra_dim)                       # reading position of peak from peak list in Sparky format
print ("---> finished")


Peaks = calc_peak_points(Points_number, Peaks, SW_size_ppm, Centr_data)

"""Noise calculation"""
print ("Noise calculation - start")
List_of_noise_points = find_noise_point(Peaks, Spectra_dim, Points_number, number_of_points_for_noise)
L_list, R_list, N_Tiles = calc_list_of_points(List_of_noise_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
Points_intens = read_intens(file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles, List_of_noise_points)
average_noise_level = round(sum(list(map(abs,Points_intens)))/len(Points_intens), -1)
print ("average noise level", average_noise_level)
print ("Noise calculation - finished")


"""Center peaks and read intens"""
print ("Center peaks and read intens - start")

for indexpeak, one_peak in enumerate(Peaks):
    Try_position = one_peak.peak_points_pos
    while one_peak.is_center == False:
        List_of_around_points = find_points_around(Try_position,Spectra_dim, Points_number)
        # one_peak.is_center = True
        L_list, R_list, N_Tiles = calc_list_of_points(List_of_around_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
        Points_intens = read_intens(file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles, Peaks)
        if Points_intens[0] > average_noise_level*50:
            if Points_intens.index(max(Points_intens)) != 0:
                Try_position = List_of_around_points[Points_intens.index(max(Points_intens))]
                print ("Peak:", indexpeak, "must move")
            else:
                one_peak.is_center = True
                print ("Peak:", indexpeak, "is in the highest place")
        else: 
            one_peak.is_visible = False
            print ("Peak:", indexpeak, "is not visible")
            break

print ("Center peaks and read intens - finished")
# print (peak_position)


# print ("\n\nKONIEC\n\n")
# Try_point_list=[692]
# try_point(Try_point_list)