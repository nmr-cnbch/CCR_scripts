#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 15 12:55 2022

@author: Paulina Bartosinska-Marzec
"""
""" Program do czytania widm w formacie ucsf i wypisywanie wartości dla danych punktów w widmie """

""" terminal: python3 read_ucsf [spectra path] [peak list] [] [] """

import binascii
from copy import deepcopy
from importlib.resources import read_binary
import math
from random import randint
import readline
import struct
import sys

import numpy
# import struct
# import _struct

file_name = sys.argv[1]
peak_list = sys.argv[2]

if len(sys.argv)>3:
    number_of_points_for_noise=int(sys.argv[3])
else:
    number_of_points_for_noise=10



class CPeak():
    def __init__(self):
        self.peak_pos = []            # chemical shifts for all nuclei of peak, length depends on dimentionality
        self.peak_points_pos = []      # peak position in points
        self.is_visible = False         # if peak height is 50 time biger than noise level = True
        self.is_center = False          # if peak is in the highest st point = True
        self.peak_intens = 0            # peak height  









"""Reading functions"""



def read_peaklist(peak_list, s_dim):
    with open(peak_list, 'r') as pl:
        p_lines = pl.readlines()
        p_list = []
        p_pos=CPeak()
        for indexl, line in enumerate(p_lines):
            if indexl > 1 :
                p_pos.peak_pos = line.split()
                # print ("p_pos.peak_pos", p_pos.peak_pos)
                if len(p_pos.peak_pos)>s_dim: 
                    s = s_dim-1
                    e = len(p_pos.peak_pos)-1
                    del p_pos.peak_pos[0]
                    del p_pos.peak_pos[s_dim:len(p_pos.peak_pos)]
                p_pos.peak_pos.insert(0,p_pos.peak_pos.pop())
                # print ("p_pos.peak_pos", p_pos.peak_pos)
                for i in range(len(p_pos.peak_pos)):
                    p_pos.peak_pos[i]=float(p_pos.peak_pos[i])
                p_list.append(deepcopy(p_pos))
                # print (p_pos.peak_pos)
                
    return p_list


def read_dim(file_name):                                                # dimension of spectrum 
    with open(file_name, "rb") as ucsf_file:
        ucsf_file.seek(10)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        # hex_data = binascii.hexlify(ucsf_data)
        # bytes2int = int.from_bytes(ucsf_data, byteorder='big')
        # print ("dimension of spectrum", ucsf_data, "\t", bytes2int)
        spectra_dim = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value   
    return spectra_dim


def read_format(file_name):                     #format version number
    with open(file_name, "rb") as ucsf_file:
        ucsf_file.seek(13)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        # hex_data = binascii.hexlify(ucsf_data)
        # bytes2int = int.from_bytes(ucsf_data, byteorder='big')
        # print ("format version number", ucsf_data, "\t", bytes2int)
        spectra_format = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value  
    return spectra_format


def read_nucl_name(file_name, s_dim):                     #nucleus name
    nucl_name = []
    with open(file_name, "rb") as ucsf_file:
        for i in range(0,s_dim):
            ucsf_file.seek(180+128*i)                                       # nucleus name (1H, 13C, 15N, 31P); first is after 180 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(6)                                   # 6 byte per information 
            # hex_data = binascii.hexlify(ucsf_data)
            # text_string = hex_data.decode('utf-8')
            text_data = ucsf_data.decode('utf-8')                           # convert bytes to string    
            # print ("nucleus name", ucsf_data, "\t", text_data)
            # print (text_data)
            nucl_name.append(deepcopy(text_data))
            # print (nucl_name[0])
        nucl_name.insert(0,nucl_name.pop())
        # print ("tutaj", nucl_name[0], nucl_name[1],nucl_name[2],nucl_name[3])
        # for ii in range(len(nucl_name)):
        #     print("bbb", nucl_name[ii])
        # print (nucl_name)
    return nucl_name        


def read_points_number(file_name, s_dim):
    with open(file_name, "rb") as ucsf_file:
        points_num =[]
        for i in range(0,s_dim):
            ucsf_file.seek(188+128*i)                                       # integer number of data points along axis; first is after 188 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("points_num", ucsf_data, "\t", bytes2int)
            points_num.append(deepcopy(bytes2int)) 
        points_num.insert(0,points_num.pop())
        # print (points_num)
    return points_num


def read_tile_size(file_name, s_dim):                     #integer tile size along this axis
    with open(file_name, "rb") as ucsf_file:
        tile_size =[]
        for i in range(0,s_dim):
            ucsf_file.seek(196+128*i)                                       # integer tile size along this axis; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            # hex_data = binascii.hexlify(ucsf_data)
            # text_string = hex_data.decode('utf-8')
            # text_data = ucsf_data.decode('utf-8')
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("tile size", ucsf_data, "\t", bytes2int)
            tile_size.append(deepcopy(bytes2int))
        tile_size.insert(0,tile_size.pop())
        # print (tile_size)
    return tile_size


def read_spectrometer_frequency(file_name, s_dim):                     #float spectrometer frequency for this nucleus (MHz) 
    with open(file_name, "rb") as ucsf_file:
        sfq =[]
        for i in range(0,s_dim):
            ucsf_file.seek(200+128*i)                                       # float spectrometer frequency for this nucleus (MHz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            # hex_data = binascii.hexlify(ucsf_data)
            # text_string = hex_data.decode('utf-8')
            # text_data = ucsf_data.decode('utf-8')
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            # bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("sfq", ucsf_data, "\t", bytes2float)
            sfq.append(deepcopy(bytes2float))
        sfq.insert(0,sfq.pop())
        # print (sfq)
    return sfq


def read_SW(file_name, s_dim, spectr_fq, points_num):                     #float spectral width (Hz) 
    sw = []
    sw_ppm = []
    with open(file_name, "rb") as ucsf_file:
        for i in range(0,s_dim):
            ucsf_file.seek(204+128*i)                                       # float spectral width (Hz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            # hex_data = binascii.hexlify(ucsf_data)
            # text_string = hex_data.decode('utf-8')
            # text_data = ucsf_data.decode('utf-8')
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            # bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("sw", ucsf_data, "\t", bytes2float)
            sw.append(deepcopy(bytes2float))
        sw.insert(0,sw.pop())
    for p in range(len(sw)):
        sw_sparky = sw[p]-(sw[p]/points_num[p])
        sw_ppm.append(deepcopy(sw_sparky/spectr_fq[p]))
    # print (sw, "\n", sw_ppm)
    return sw, sw_ppm


def read_centr_data(file_name, s_dim):                     #float center of data (ppm) 
    with open(file_name, "rb") as ucsf_file:
        centr_data =[]
        for i in range(0,s_dim):
            ucsf_file.seek(208+128*i)                                       # float center of data (ppm) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            # hex_data = binascii.hexlify(ucsf_data)
            # text_string = hex_data.decode('utf-8')
            # text_data = ucsf_data.decode('utf-8')
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            # bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("centr_data", ucsf_data, '\t', bytes2float)
            centr_data.append(deepcopy(bytes2float))
        centr_data.insert(0,centr_data.pop())
        # print (centr_data)
    return centr_data




"""Calculating functions"""




def ppm2points(ppm, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    point_value = round((downfield-ppm)/(sw_div_fnz))
    # print ("point_value", ppm, "--->", point_value_float, "--->", point_value)
    return point_value


def calc_peak_points(points_num, peaks, sw_ppm, center_data):
    # peak_point=[]
    for peak_num in range(len(peaks)):
        # one_peak=[]
        for p in range(len(peaks[peak_num].peak_pos)):
            one_dim = ppm2points(peaks[peak_num].peak_pos[p],points_num[p],center_data[p],sw_ppm[p])
            # one_peak.append(deepcopy(one_dim))
            peaks[peak_num].peak_points_pos.append(deepcopy(one_dim))
        # peak_point.append(deepcopy(one_peak))
        # print (peaks[peak_num].peak_pos, peaks[peak_num].peak_points_pos)

    # print ("peak_point", peak_point)
    return peaks


def find_noise_point(peaks, s_dim, points_num, number_of_points_for_noise):

    dumpster=[]                              # list of wrong points: e.g. it's peak or really close to peak
    for i in range(len(peaks)):
        dumpster.append(deepcopy(peaks[i].peak_points_pos))
    suspect_peaks=[]                                        # list of peaks which probably are too close to our random point
    list_of_points=[]                 # list of good points with noise

    first_try = [None]*s_dim


    print ("number_of_points_for_noise", number_of_points_for_noise**(1+s_dim))
    ii=1
    while len(list_of_points)< number_of_points_for_noise**(1+s_dim):
        
        for f in range(len(first_try)):
            first_try[f]=randint(0,points_num[f]-1) # points_num[f]-1 because it takes too big number
        
        # print (first_try)
        if first_try not in dumpster:
            # print ("first_try - ok")
            for indexi, one_peak in enumerate(peaks):
                if first_try[0] in range (one_peak.peak_points_pos[0]-3, one_peak.peak_points_pos[0]+3):
                    suspect_peaks.append(deepcopy(one_peak.peak_points_pos))
                    for i in range(1,len(one_peak.peak_points_pos)):
                        if first_try[i] not in range (one_peak.peak_points_pos[i]-3, one_peak.peak_points_pos[i]+3):
                            suspect_peaks.pop()
                            break
            # print ("suspect_peaks", ii, suspect_peaks)

            if len(suspect_peaks) == 0:
                list_of_points.append(deepcopy(first_try))
            else:
                dumpster.append(deepcopy(suspect_peaks))
            suspect_peaks.clear()
            ii+=1
    # print (list_of_points)
    print ("ile wyrzuciles?", len(peaks), "--->", len(dumpster))

    return list_of_points


def calc_list_of_points(peak_point, s_dim, tile_size, points_num):
    n_tiles=[]                                 # number of tiles along axis [direct, 1, 2, 3]
    L=[]                                        # tile number with our peak -1
    R=[]                                        # point number with peak in tile  

    for i in range (0,s_dim):
        if points_num[i]%tile_size[i]==0:
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])))
        else: 
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])+1))
    
    for indexp, one_peak_point in enumerate(peak_point):
        # print ("\nnumer piku", indexp+1)
        l=[]
        r=[]
        for p in range(len(one_peak_point)):
            l.append(deepcopy(one_peak_point[p]//tile_size[p]))
            r.append(deepcopy(one_peak_point[p]%tile_size[p]))
            # print ("ppm2points", one_peak_point[p], "--",tile_size[p],"--> l =", l[p], "r =", r[p])
            # print ("ppm2points", one_peak_point[p], "---->", peak_point, "--",tile_size[p],"--> points_num =", points_num[p], "center_data =", center_data[p],"sw_ppm =", sw_ppm[p])
            # # print ("ppm2points", one_peak_point[p], "---->", peak_point)
        R.append(deepcopy(r))
        L.append(deepcopy(l))
    # print ("\n\nlisty L", L, "\nn_tiles", n_tiles, "\nR", R, "\n\n")

    return L, R, n_tiles


def read_intens(file_name, s_dim, tile_size, L, R, n_tiles, peak_pos_list):

    intens_list=[]

    for k in range(len(peak_pos_list)):
        
        '''  Calculation starting point in ucsf file for peak "k"  '''

        ppos = [None]*s_dim*2
        # print ("\n\nNUMER_PIKU = ", k+1, "\n")

        
        for D in range(1,s_dim):
            pp = 1
            rr = 1
            for d in range(D+1,s_dim):
                pp = pp * n_tiles[d]                        # Calculating terms with quantities and sizes of tiles
                rr = rr * tile_size[d]                      # Calculating terms with position points in a given tiles
                # print ("pp_1", pp, "= pp * n_tiles(", n_tiles[d], ")", "\t\td = ", d)
                # print ("rr_1", rr, "= rr * tile_size(", tile_size[d], ")", "\t\td = ", d)
            pp = pp * L[k][D] * numpy.prod(tile_size) * n_tiles[0]
            rr = rr * R[k][D] * tile_size[0]
            # print ("\npp_2 =", pp, "rr_2 =", rr, "L =", L[k][D], "D =", D, D+s_dim)
            ppos[D-1]=pp
            ppos[D-1+s_dim]=rr
        ppos[s_dim-1]=L[k][0] * numpy.prod(tile_size)
        ppos[s_dim*2-1]=R[k][0]
        ppos_sum=180+128*s_dim+sum(ppos)*4
        # print ("\nnumer_piku = ", k+1, "\tppos_sum = ", ppos_sum, "przed:", sum(ppos))
        # print ("ppos", ppos)

        '''  Reading value from ucsf file for peak "k"  '''
        with open(file_name, "rb") as ucsf_file:
            ucsf_file.seek(ppos_sum)                                       
            ucsf_data = ucsf_file.read(4)
            # print (ucsf_data)
            [bytes2float] = struct.unpack('>f', ucsf_data)
            # print ("bytes2float", bytes2float)
            intens_list.append(deepcopy(bytes2float))
        
    # print ("\nintens_list", intens_list)

    average_noise_level = round(sum(list(map(abs,intens_list)))/len(intens_list), -1)
    # print ("\naverage noise level", average_noise_level, "from absolute value of intensity")
    print ("average noise level", average_noise_level)

    return intens_list


# def find_peak_maximum(peak_point, s_dim, points_num, number_of_points_for_noise):

#     dumpster=peak_point[:]                              # list of wrong points: e.g. it's peak or really close to peak
#     suspect_peaks=[]                                        # list of peaks which probably are too close to our random point
#     list_of_points=[]                 # list of good points with noise

#     first_try = [None]*s_dim



#     return list_of_points


def try_point (try_list):
    # for indexi, i in enumerate (try_list):
    for i in range(692,400692,4):
        with open(file_name, "rb") as ucsf_file:
            ucsf_file.seek(i)                                       
            ucsf_data = ucsf_file.read(4)
            # print (ucsf_data)
            [bytes2float] = struct.unpack('>f', ucsf_data)
            # print ("bytes2float", bytes2float)
            print ("try_point =", i, "\t---> intensyty =", bytes2float)



"""                      MAIN PROGRAM                      """

# print ("\n\nSTART")
"""File Reading"""
print ("File reading - start")
Spectra_dim = read_dim(file_name)                                           # reading dimension of spectrum from ucsf file
Peaks = read_peaklist(peak_list, Spectra_dim)                       # reading position of peak from peak list in Sparky format
Points_number = read_points_number(file_name, Spectra_dim)                  # reading integer number of data points along axis from ucsf file (fnz)
Tile_size = read_tile_size(file_name, Spectra_dim)                          # reading integer tile size along this axis from ucsf file
Spectrometer_fq = read_spectrometer_frequency(file_name, Spectra_dim)       # reading float spectrometer frequency for this nucleus (MHz) from ucsf file
SW_size, SW_size_ppm = read_SW(file_name, Spectra_dim, Spectrometer_fq, Points_number)     # reading float spectral width (Hz) from ucsf file
Centr_data = read_centr_data(file_name, Spectra_dim)                        # reading float center of data (ppm) from ucsf file
print ("File reading - finished")


Peaks = calc_peak_points(Points_number, Peaks, SW_size_ppm, Centr_data)

"""Noise calculation"""
print ("Noise calculation - start")
List_of_noise_points = find_noise_point(Peaks, Spectra_dim, Points_number, number_of_points_for_noise)
L_list, R_list, N_Tiles = calc_list_of_points(List_of_noise_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
Points_intens = read_intens(file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles, List_of_noise_points)
print ("Noise calculation - finished")

# """Center peaks and read intens"""
# print ("Center peaks and read intens - start")
# List_of_points = find_peak_maximum(Peak_Point, Spectra_dim, Points_number, number_of_points_for_noise)
# L_list, R_list, N_Tiles = calc_list_of_points(List_of_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
# Peak_intens = read_intens(file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles, List_of_points)
# print ("Center peaks and read intens - finished")
# print (peak_position)


# print ("\n\nKONIEC\n\n")
# Try_point_list=[692]
# try_point(Try_point_list)