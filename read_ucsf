#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Feb 15 12:55 2022

@author: Paulina Bartosinska-Marzec
"""
""" Program do czytania widm w formacie ucsf i wypisywanie wartości dla danych punktów w widmie """

""" terminal: python3 read_ucsf [spectra path] [peak list] --np [] """


from copy import deepcopy
from random import randint
import struct
import sys
from itertools import product
import os
import numpy


if len(sys.argv)==1:
    sys.exit("""
    read_ucsf script after reading ucsf file and peak list (in Sparky format), check peak intensity of peak and if it is not in the highest position - move it. 
    After this script prints peak lists in ppm value and points value.
    
    For run script type in command line:
        python3 read_point_list_and_compere [peak list1 path] [peak list2 path] [peak list3 path]...[peak listN path]
      
    additionaly you can add:
        --ns []   - to change number of points for calculate noise level: N^(spectra dimentionality + 1); normally is N = 10\n""")



file_name = sys.argv[1]
peak_list = sys.argv[2]

if len(sys.argv)>3:
    if "--np" in sys.argv:
        i = sys.argv.index("--np")
        number_of_points_for_noise=int(sys.argv[i+1])
else:
    number_of_points_for_noise=10

print (number_of_points_for_noise)


class CPeak:
    def __init__(self):
        self.peak_ppm_pos = []            # chemical shifts for all nuclei of peak, length depends on dimentionality
        self.peak_points_pos = []      # peak position in points
        self.is_visible = True         # if peak height is 50 time biger than noise level = True
        self.peak_intens = 0            # peak height  
        self.descript = ""              
        self.is_center = False          # if peak is in the highest point = True
        self.was_moved = False          # if peak was moved = True
        self.new_points_pos = []         # if peak was moved there will be new position in points
        self.new_ppm_pos = []           # if peak was moved there will be new position in ppm









"""Reading functions"""

def read_peaklist(peak_list, s_dim):
    with open(peak_list, 'r') as pl:
        p_lines = pl.readlines()
        p_list = []
        for indexl, line in enumerate(p_lines):
            if indexl > 1 :
                p_pos = CPeak()
                item = line.split()
                p_pos.descript = item[0]
                # print ("p_pos.peak_ppm_pos", p_pos.peak_ppm_pos)
                p_pos.peak_ppm_pos.append(deepcopy(float(item[s_dim])))
                for i in range(1,s_dim):
                    p_pos.peak_ppm_pos.append(deepcopy(float(item[i])))
                p_list.append(deepcopy(p_pos))
                # print (p_pos.peak_ppm_pos)       
    return p_list


def read_ucsf_info(file_name):
    nucl_name = []
    points_num = []
    tile_size = []
    spectr_fq =[]
    sw = []
    sw_ppm = []
    centr_data = []

    with open(file_name, "rb") as ucsf_file:
        """Read spectra dimentionality"""
        ucsf_file.seek(10)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_dim = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value 

        """Read spectra format"""
        ucsf_file.seek(13)
        ucsf_data = ucsf_file.read(1)                                   # 1 byte per information 
        spectra_format = int.from_bytes(ucsf_data, byteorder='big')         # convert bytes to integer value  

        """Read nucleus name"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(180+128*i)                                       # nucleus name (1H, 13C, 15N, 31P); first is after 180 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(6)                                   # 6 byte per information 
            text_data = ucsf_data.decode('utf-8')                           # convert bytes to string    
            # print ("nucleus name", ucsf_data, "\t", text_data)
            # print (text_data)
            nucl_name.append(deepcopy(text_data))
            # print (nucl_name[0])
        nucl_name.insert(0,nucl_name.pop())
        # print ("tutaj", nucl_name[0], nucl_name[1],nucl_name[2],nucl_name[3])
        # for ii in range(len(nucl_name)):
        #     print("bbb", nucl_name[ii])
        # print (nucl_name)

        """Read number of points per asix"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(188+128*i)                                       # integer number of data points along axis; first is after 188 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("points_num", ucsf_data, "\t", bytes2int)
            points_num.append(deepcopy(bytes2int)) 
        points_num.insert(0,points_num.pop())

        """Read integer tile size along this axis"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(196+128*i)                                       # integer tile size along this axis; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            bytes2int = int.from_bytes(ucsf_data, byteorder='big')          # convert bytes to integer value  
            # print ("tile size", ucsf_data, "\t", bytes2int)
            tile_size.append(deepcopy(bytes2int))
        tile_size.insert(0,tile_size.pop())
        # print (tile_size)

        """Read float spectrometer frequency for this nucleus (MHz) """
        for i in range(0,spectra_dim):
            ucsf_file.seek(200+128*i)                                       # float spectrometer frequency for this nucleus (MHz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            spectr_fq.append(deepcopy(bytes2float))
        spectr_fq.insert(0,spectr_fq.pop())
        # print (spectr_fq)

        """Read float spectral width (Hz)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(204+128*i)                                       # float spectral width (Hz) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            sw.append(deepcopy(bytes2float))
        sw.insert(0,sw.pop())

        """Read float center of data (ppm)"""
        for i in range(0,spectra_dim):
            ucsf_file.seek(208+128*i)                                       # float center of data (ppm) ; first is after 196 bytes, next one is after additional 128 bytes
            ucsf_data = ucsf_file.read(4)                                   # 4 byte per information 
            [bytes2float] = struct.unpack('>f', ucsf_data)                  # convert bytes to float value
            centr_data.append(deepcopy(bytes2float))
        centr_data.insert(0,centr_data.pop())
        # print (centr_data)

    """Change spectral width from Hz to ppm"""
    for p in range(len(sw)):
        sw_sparky = sw[p]-(sw[p]/points_num[p])
        sw_ppm.append(deepcopy(sw_sparky/spectr_fq[p]))
    # print (sw, "\n", sw_ppm)
    return spectra_dim, nucl_name, points_num, tile_size, spectr_fq, sw, sw_ppm, centr_data







"""Calculating functions"""

def ppm2points(ppm, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    point_value = round((downfield-ppm)/(sw_div_fnz))
    return point_value


def points2ppm(point_value, points_num, center_data, sw_ppm): 
    sw_div_fnz = sw_ppm/(points_num-1)
    downfield = center_data+points_num/2*sw_div_fnz
    ppm_value = downfield-point_value*sw_div_fnz
    return ppm_value


def calc_peak_points(points_num, peaks, sw_ppm, center_data):
    # peak_point=[]
    for peak_num in range(len(peaks)):
        # one_peak=[]
        for p in range(len(peaks[peak_num].peak_ppm_pos)):
            one_dim = ppm2points(peaks[peak_num].peak_ppm_pos[p],points_num[p],center_data[p],sw_ppm[p])
            # one_peak.append(deepcopy(one_dim))
            peaks[peak_num].peak_points_pos.append(deepcopy(one_dim))
        # peak_point.append(deepcopy(one_peak))
        # print (peaks[peak_num].peak_ppm_pos, peaks[peak_num].peak_points_pos)

    # print ("peak_point", peak_point)
    return peaks


def find_noise_point(peaks, s_dim, points_num, number_of_points_for_noise):

    dumpster=[]                              # list of wrong points: e.g. it's peak or really close to peak
    for i in range(len(peaks)):
        dumpster.append(deepcopy(peaks[i].peak_points_pos))
    suspect_peaks=[]                                        # list of peaks which probably are too close to our random point
    list_of_points=[]                 # list of good points with noise

    first_try = [None]*s_dim


    print ("number_of_points_for_noise", number_of_points_for_noise**(1+s_dim))
    ii=1
    while len(list_of_points)< number_of_points_for_noise**(1+s_dim):
        
        for f in range(len(first_try)):
            first_try[f]=randint(0,points_num[f]-1) # points_num[f]-1 because it takes too big number
        
        # print (first_try)
        if first_try not in dumpster:
            # print ("first_try - ok")
            for indexi, one_peak in enumerate(peaks):
                if first_try[0] in range (one_peak.peak_points_pos[0]-3, one_peak.peak_points_pos[0]+3):
                    suspect_peaks.append(deepcopy(one_peak.peak_points_pos))
                    for i in range(1,len(one_peak.peak_points_pos)):
                        if first_try[i] not in range (one_peak.peak_points_pos[i]-3, one_peak.peak_points_pos[i]+3):
                            suspect_peaks.pop()
                            break
            # print ("suspect_peaks", ii, suspect_peaks)

            if len(suspect_peaks) == 0:
                list_of_points.append(deepcopy(first_try))
            else:
                dumpster.append(deepcopy(suspect_peaks))
            suspect_peaks.clear()
            ii+=1
    # print (list_of_points)
    print ("ile wyrzuciles?", len(peaks), "--->", len(dumpster))

    return list_of_points


def calc_list_of_points(peak_point, s_dim, tile_size, points_num):
    n_tiles=[]                                 # number of tiles along axis [direct, 1, 2, 3]
    L=[]                                        # tile number with our peak -1
    R=[]                                        # point number with peak in tile  

    for i in range (0,s_dim):
        if points_num[i]%tile_size[i]==0:
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])))
        else: 
            n_tiles.append(deepcopy(int(points_num[i]/tile_size[i])+1))
    
    for indexp, one_peak_point in enumerate(peak_point):
        # print ("\nnumer piku", indexp+1)
        l=[]
        r=[]
        for p in range(len(one_peak_point)):
            l.append(deepcopy(one_peak_point[p]//tile_size[p]))
            r.append(deepcopy(one_peak_point[p]%tile_size[p]))
            # print ("ppm2points", one_peak_point[p], "--",tile_size[p],"--> l =", l[p], "r =", r[p])
            # print ("ppm2points", one_peak_point[p], "---->", peak_point, "--",tile_size[p],"--> points_num =", points_num[p], "center_data =", center_data[p],"sw_ppm =", sw_ppm[p])
            # # print ("ppm2points", one_peak_point[p], "---->", peak_point)
        R.append(deepcopy(r))
        L.append(deepcopy(l))
    # print ("\n\nlisty L", L, "\nn_tiles", n_tiles, "\nR", R, "\n\n")

    return L, R, n_tiles


def read_intens(peak_pos_list, file_name, s_dim, tile_size, L, R, n_tiles):

    intens_list=[]

    for k in range(len(peak_pos_list)):
        
        '''  Calculation starting point in ucsf file for peak "k"  '''

        ppos = [None]*s_dim*2
        # print ("\n\nNUMER_PIKU = ", k+1, "\n")

        # print ("długość k =", len(peak_pos_list))
        # print ("tile_size", tile_size)
        # print ("długość L =", len(L), L[k])
        # print ("długość R =", len(R), R[k])
        for D in range(1,s_dim):
            # print ("D =", D)
            pp = 1
            rr = 1
            for d in range(D+1,s_dim):
                # print ("d =", d)
                pp = pp * n_tiles[d]                        # Calculating terms with quantities and sizes of tiles
                rr = rr * tile_size[d]                      # Calculating terms with position points in a given tiles
                # print ("pp_1", pp, "= pp * n_tiles(", n_tiles[d], ")", "\t\td = ", d)
                # print ("rr_1", rr, "= rr * tile_size(", tile_size[d], ")", "\t\td = ", d)
            pp = pp * L[k][D] * numpy.prod(tile_size) * n_tiles[0]
            rr = rr * R[k][D] * tile_size[0]
            # print ("\npp_2 =", pp, "rr_2 =", rr, "L =", L[k][D], "D =", D, D+s_dim)
            ppos[D-1]=pp
            ppos[D-1+s_dim]=rr
        ppos[s_dim-1]=L[k][0] * numpy.prod(tile_size)
        ppos[s_dim*2-1]=R[k][0]
        ppos_sum=180+128*s_dim+sum(ppos)*4
        # print ("\nnumer_piku = ", k+1, "\tppos_sum = ", ppos_sum, "przed:", sum(ppos))
        # print ("ppos", ppos)

        '''  Reading value from ucsf file for peak "k"  '''
        with open(file_name, "rb") as ucsf_file:
            ucsf_file.seek(ppos_sum)                                       
            ucsf_data = ucsf_file.read(4)
            # print (ucsf_data)
            [bytes2float] = struct.unpack('>f', ucsf_data)
            # print ("bytes2float", bytes2float)
            intens_list.append(deepcopy(bytes2float))
        
    # print ("\nintens_list", intens_list)

    return intens_list


def find_points_around(try_position, orgin_pos, vector_set, s_dim):
    list_of_points=[]

    for i in range (len(vector_set)):
        Flag = False
        one_point = []
        for j in range (s_dim):
            new_point = try_position[j] + vector_set[i][j]
            if abs(new_point-orgin_pos[j])<=2:
                one_point.append(deepcopy(new_point))
            else:
                Flag = True
        if Flag==False:
            list_of_points.append(deepcopy(one_point))
    # print ("\n\n wersja 1",list_of_points)


    return list_of_points


def Print_Peak_List_ppm(peaks, s_dim, points_num, sw_ppm, center_data):
    item = peak_list.split("/")
    peak_list_name = item[len(item)-1][:-5]
    peak_list_dir_new = peak_list[:-(len(peak_list_name)+5)]+peak_list_name
    if not os.path.exists(peak_list_dir_new):
        os.mkdir(peak_list_dir_new)
    new_peak_list = "{0}/{1}_new_ppm.list".format(peak_list_dir_new,peak_list_name)
    print ("new_peak_list", new_peak_list)
    with open(new_peak_list, 'w') as listfile:
        print ("\tAssignment", end="", file=listfile) 
        for i in range(s_dim):
            print ("\tw{}".format(i+1), end="", file=listfile)
        print ("\tData Height\t\t\t\tCentering peak list prepare from{}\n".format(peak_list_name), file=listfile)
        for indexpeak, one_peak in enumerate(peaks):
            if one_peak.is_visible == True:
                print ("{}".format(one_peak.descript), end="\t", file=listfile)
                if one_peak.was_moved == True and one_peak.is_center != False:
                    for i in range(1,s_dim):
                        ppm_position = points2ppm(one_peak.new_points_pos[i], points_num[i],center_data[i],sw_ppm[i])
                        print ("{:.3f}".format(ppm_position), end="\t", file=listfile)
                    ppm_position = points2ppm(one_peak.new_points_pos[0], points_num[0],center_data[0],sw_ppm[0])
                    print ("{:.3f}".format(ppm_position), end="\t", file=listfile)
                        
                else: 
                    for i in range(1,s_dim):
                        print ("{:.3f}".format(one_peak.peak_ppm_pos[i]), end="\t", file=listfile)
                    print ("{:.3f}".format(one_peak.peak_ppm_pos[0]), end="\t", file=listfile)
                print (one_peak.intens, end=" ", file=listfile) 
                
                if one_peak.is_center == False:
                    print ("to check", file=listfile)
                else: print (file=listfile)
    return

def Print_Peak_List_points(peaks, s_dim, type_list):
    item = peak_list.split("/")
    peak_list_name = item[len(item)-1][:-5]
    peak_list_dir_new = peak_list[:-(len(peak_list_name)+5)]+peak_list_name
    if not os.path.exists(peak_list_dir_new):
        os.mkdir(peak_list_dir_new)
    new_peak_list = "{0}/{1}_{2}_points.list".format(peak_list_dir_new,peak_list_name,type_list)
    print ("{} peak list".format(type_list), new_peak_list)
    with open(new_peak_list, 'w') as listfile:
        print ("\tAssignment", end="", file=listfile) 
        for i in range(s_dim):
            print ("\tw{}".format(i+1), end="", file=listfile)
        if type_list == "orgin":
            print ("\tData Height\t\t\t\t Orgin peaklist in points\n", file=listfile)
        else:
            print ("\tData Height\t\t\t\tCentering peak list prepare from{}\n".format(peak_list_name), file=listfile)
        for one_peak in peaks:
            if one_peak.is_visible == True:
                print ("{}".format(one_peak.descript), end="\t", file=listfile)
                if one_peak.was_moved == True and one_peak.is_center != False:
                    for i in range(1,s_dim):
                        print ("{}".format(one_peak.new_points_pos[i]), end="\t", file=listfile)
                    print ("{}".format(one_peak.new_points_pos[0]), end="\t", file=listfile)
                else: 
                    for i in range(1,s_dim):
                        print ("{}".format(one_peak.peak_points_pos[i]), end="\t", file=listfile)
                    print ("{}".format(one_peak.peak_points_pos[0]), end="\t", file=listfile)
                if type_list=="new":
                    print (one_peak.intens, end=" ", file=listfile) 
                    if one_peak.is_center == False:
                        print ("to check", file=listfile)
                    else: print (file=listfile)
                else: print (file=listfile)
    return





















"""                      MAIN PROGRAM                      """

# print ("\n\nSTART")
"""File Reading"""

print ("File reading - start", end=" ")
Spectra_dim, Nucl_name, Points_number, Tile_size, Spectrometer_fq, SW_size, SW_size_ppm, Centr_data = read_ucsf_info (file_name)
Peaks = read_peaklist(peak_list, Spectra_dim)                       # reading position of peak from peak list in Sparky format
print ("---> finished")


Peaks = calc_peak_points(Points_number, Peaks, SW_size_ppm, Centr_data)
OldPeakList_points = Print_Peak_List_points(Peaks, Spectra_dim, "orgin")

"""Noise calculation"""
print ("\nNoise calculation - start")
List_of_noise_points = find_noise_point(Peaks, Spectra_dim, Points_number, number_of_points_for_noise)
L_list, R_list, N_Tiles = calc_list_of_points(List_of_noise_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
Points_intens = read_intens(List_of_noise_points, file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles)
average_noise_level = round(sum(list(map(abs,Points_intens)))/len(Points_intens), -1)
print ("average noise level = {:.2e}".format(average_noise_level))
print ("50*average noise level = {:.2e}".format(50*average_noise_level))
print ("Noise calculation - finished")


"""Center peaks and read intens"""
print ("\nCenter peaks and read intens - start")
Peak_not_moved = 0
Peak_moved = 0
Vector_set = [list(row) for row in (product([-1, 0, 1],repeat=4))]

with open('peakcenter.txt', 'w') as txtfile:
    print ("Peak_not_moved =     \nPeak_moved =     ",file=txtfile)
for indexpeak, one_peak in enumerate(Peaks):
    Try_position = one_peak.peak_points_pos
    Orgin_pos = one_peak.peak_points_pos
    try_pos=[]
    try_intens=[]
    # try_pos.append(deepcopy(Try_position))
    while one_peak.is_center == False:
        List_of_around_points = find_points_around(Try_position, Orgin_pos, Vector_set, Spectra_dim)
        try_index = List_of_around_points.index(Try_position)
        L_list, R_list, N_Tiles = calc_list_of_points(List_of_around_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
        Points_intens = read_intens(List_of_around_points, file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles)
        try_pos.append(deepcopy(Try_position))
        try_intens.append(deepcopy(Points_intens[try_index]))

        if Points_intens[try_index] > average_noise_level*50:
            if Points_intens.index(max(Points_intens)) != try_index:            # if current position of peak is not the highest: index of the highest point is not equal 0 (0 is index of current peak position)
                Try_position = List_of_around_points[Points_intens.index(max(Points_intens))]
                # print ("Peak:", indexpeak, "must move")
                one_peak.was_moved = True
            else:
                one_peak.is_center = "maybe"
                one_peak.intens = Points_intens[try_index]
                # print ("Peak:", indexpeak, "is in the highest place")
                
                if one_peak.was_moved == True:
                    one_peak.new_points_pos = Try_position
                    Peak_moved +=1
                    # try_pos.append(deepcopy(Try_position))
                else: Peak_not_moved +=1
        else: 
            one_peak.is_visible = False
            # print ("Peak:", indexpeak, "is not visible")
            break

    #check if peak is in the highest position
    List_of_around_points = find_points_around(Try_position, Try_position, Vector_set, Spectra_dim)
    try_index = List_of_around_points.index(Try_position)
    L_list, R_list, N_Tiles = calc_list_of_points(List_of_around_points, Spectra_dim, Tile_size, Points_number) # L_list: tile number with our peak -1; R_list: point number with peak in tile; Tiles_num: number of tiles along axis [direct, 1, 2, 3]
    Points_intens = read_intens(List_of_around_points, file_name, Spectra_dim, Tile_size, L_list, R_list, N_Tiles)
    if Points_intens.index(max(Points_intens)) == try_index:
        one_peak.is_center = True
    else: 
        one_peak.is_center = False

    with open('peakcenter.txt', 'a') as txtfile:
        if one_peak.is_visible == False:
            print ("\n{}\t({})\t- is not visible".format(indexpeak, one_peak.descript), file=txtfile)
        else:
            print ("\n{}\t({})".format(indexpeak, one_peak.descript), file=txtfile)

        for i in range(len(try_pos)):
            print ("\t", try_pos[i], try_intens[i], sep="\t", file=txtfile)
        if one_peak.is_center == False:
            print ("is not in the highest position", file=txtfile)

with open('peakcenter.txt', 'r+') as txtfile:
    # file_data = txtfile.read()
    txtfile.seek(0,0)
    # txtfile.write()
    print ("Peak_not_moved = {}\nPeak_moved = {}".format(Peak_not_moved,Peak_moved),file=txtfile)

print ("Center peaks and read intens - finished")


"""Print peak list"""
print ("\nPrint peak list - start")

NewPeakList_ppm = Print_Peak_List_ppm(Peaks, Spectra_dim, Points_number, SW_size_ppm, Centr_data)
NewPeakList_points = Print_Peak_List_points(Peaks, Spectra_dim, "new")
print ("\nPrint peak list - finish")


print ("\n\nKONIEC\n\n")
# Try_point_list=[692]
# try_point(Try_point_list)